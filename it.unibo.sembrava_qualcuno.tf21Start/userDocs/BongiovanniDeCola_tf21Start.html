<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
		<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
		<script type="text/javascript" src="../css/issStyle.js"></script>
	-->
	<style type="text/css">
		body {
			margin-left:  30px;
			margin-right: 30px;
		}

		P {
			font-family: Tahoma;
			font-size: 10pt;
		}

		a, a:visited, a:active, a:link, a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
			font-size: 93%;
		}

		a:hover {
			background-color: #cccccc;
		}

		hr {
			clear: both;
			height: 1px;
			color: #242424;
			background-color: transparent;
		}

		h1, h2, h3 {
			color: #242424;
			clear: left;
			font: 100% Tahoma, Helvetica, Arial, sans-serif;
			margin-bottom: 0.5em;
			padding-top: 0.5em;
			border-radius: 10px;
			padding: 5px;
		}

		top {
			width: 100%;
		}

		#i {
			color: #ff1010;
		}

		tt {
			font-family: "Arial";
			font-size: 90%;
			color: #006600;
		}

		em {
			font-family: "Arial";
			font-size: 80%;
			font-weight: bold;
			border-style:solid;
			border-color: #abe876;
			color: #1632cc;
		}

		bc {
			font-family: "Arial";
			font-size: 90%;
			font-weight: bold;
			color: #990000;
			background-color: #fcf8c7;
		}

		ks {
			font-family: "Arial";
			font-weight: bold;
			color: #0000CD	;
			font-size: 90%;
		}

		kc {
			font-family: "Arial";
			font-weight: bold;
			color: #008000	;
			font-size: 90%;
		}

		pre {
			font-family: "Consolas";
			font-size: 85%;
			background-color: #f5f5f5;
			border: 1.5px solid silver;
			padding: 5px;
		}

		m {
			font-family: "Helvetica";
			line-height: 100%;
			font-size: 75%;
		}

		div.body {
			font-size: 18px;
		}

		k, lr {
			color: #990000;
			font-weight: bold;
			font-size: 90%;
		}

		h1 {
			font-size: 150%;
			background-color: #b2c0ff;
			padding: 10px;
		}

		h2 {
			background-color: #9ed8ff;
			font-size: 130%;
		}

		h3 {
			background-color: #e6ccff;
			font-size: 100%;
		}

		h4 {
			background-color: #ccffcc;
			font-size: 100%;
			width: 95%;
			border-radius: 5px;
			padding: 2px;
		}

		h5 {
			background-color: #d5ffb0;
			font-size: 100%;
		}

		div.req {
			background-color: #d9ffb3;
			font-size: 18px;
			width: 700px;
			border: 3px solid green;
			padding: 15px;
			margin: 10px;
		}

		div.remark {
			background-color: #E3F2FD;
			border: 1.5px solid #d5f2ed;
			padding: 15px;
			margin: 10px;
			border-radius: 25px;
		}

		table, th, td {
			border: 1px solid black;
			border-collapse: collapse;
		}

		ol, ul, li {
			margin: 0;
			margin-left: 10px;
			padding: 0;
			padding-bottom: 5px;
		}

		table, th, td {
			border: 1px solid black;
		}

		img {
			border: 1.5px solid #d5f2ed
		}

		a, a:visited, a:active, a:link, a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
		}

		div.wrapdesc {
			width: 90%;
			margin: auto;
		}

		div.imagedesc {
			width: 85%;
			margin: auto;
		}

		.fr li::marker {
			content: "F" counter(list-item) " ";
			color: mediumslateblue;
		}

		.nfr li::marker {
			content: "NF" counter(list-item) " ";
			color: mediumslateblue;
		}

		.sprint td {
			width: 33%;
		}
	</style>
		
	<head>
		<title>Final Task Start 2021</title>
		<script type="text/javascript">
			function onLoad() {
				setRequirementsId();
				addLrLinks();
				addAutoLinks();
			}

			function setRequirementsId() {
				var fRequirements = document.getElementsByClassName("fr")[0].children;
				var nfRequirements = document.getElementsByClassName("nfr")[0].children;
				var i;
				for(i = 0; i < fRequirements.length; i++)
					fRequirements[i].id = "F" + (i + 1);
				for(i = 0; i < nfRequirements.length; i++)
					nfRequirements[i].id = "NF" + (i + 1);
			}

			function addLrLinks() {
				var lrList = document.getElementsByTagName("lr");

				for(var i = 0; i < lrList.length; i++) {
					org_html = lrList[i].outerHTML;
					new_html = "<a href=#" + lrList[i].textContent + ">" + org_html + "</a>";
					lrList[i].outerHTML = new_html;		
			lrList[i].outerHTML = new_html;		
					lrList[i].outerHTML = new_html;		
				}
			}

			function addAutoLinks() {
				var elements = document.getElementsByClassName("al");

				for(var i = 0; i < elements.length; i++) {
					org_html = elements[i].outerHTML;
					new_html = "<a href=#" + elements[i].textContent + ">" + org_html + "</a>";
					elements[i].outerHTML = new_html;	
			elements[i].outerHTML = new_html;	
					elements[i].outerHTML = new_html;	
				}
			}
		</script>
	</head>
		
	<body onload="onLoad();">
		<div id="top">
			<h1>ISS | Final Task Start: Automated Car-Parking <font size="5"></font></h1>
		</div>   

		<div class="body"> 
			<h2>Introduction</h2>
				<div class="remark">
					Our motto:<br/>   
					<k>there is no code without a project, no project without problem analysis and no problem without requirements</k>.
				</div>
			<h2>Automated Car-Parking</h2> 
				A company intends to build an <i>automating parking service</i> composed of a set of elements:

				<ul>
					<li>A software system, named <em>ParkManagerService</em>, that implements the required automation functions.</li>
					<li>A <tt>DDR</tt> robot working as a <em>transport trolley</em>, that is intially situated in its <em>home</em> location. The <tt>transport trolley</tt> has the form of a square of side length <em>RD</em>.</li>
					<li>
						A <em>parking-area</em> is an empty room that includes:
						<ul>
							<li>an <em>INDOOR</em> to enter the car in the area. Facing the <tt>INDOOR</tt>, there is a <em>INDOOR-area</em> equipped with a <em>weigthsensor</em> that measures the <em>weigth</em> of the car;</li>
							<li>
								an <em>OUTDOOR</em> to exit from the <tt>parking-area</tt>. Just after the <tt>OUTDOOR</tt>, there is <em>OUTDOOR-area</em> equipped with a <em>outsonar</em>, used to detect the presence of a car.
								The <tt>OUTDOOR-area</tt>, once engaded by a car, should be freed within a prefixed interval of time <em>DTFREE</em>; 
							</li>
							<li>a number <tt>N (N=6)</tt> of <em>parking-slots</em>;</li>
							<li>a <em>thermometer</em> that measures the temperature <em>TA</em> of the area;</li>
							<li>a <em>fan</em> that should be activated when <k>TA > TMAX</k>, where <em>TMAX</em> is a prefixed value (e.g. <tt>35</tt>)</li>
						</ul>
						A <em>map</em> of the parking area, represented as a grid of squares of side length <em>RD</em>, 
						is available in the file <a href="parkingMap.txt" target="code">parkingMap.txt</a>:
<pre>
|r, 0, 0, 0, 0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, 0, 0, 0, 0, 0, X, 
|X, X, X, X, X, X, X, X, 
</pre>
						The map includes the positions of the  <tt>parking-slots</tt> (marked above with the symbol <k>X</k>) and of the <em>fixed obstacles</em> in the area (the walls marked with the symbol <b>X</b>).
						<br/><br/>
						The area marked with <k>X</k> is a sort of 'equipped area' upon which the <tt>transport trolley</tt> cannot walk.
						Thus, to get the car in the <tt>parking-slot</tt> <ks>(2,2)</ks>, the <tt>transport trolley</tt> must go in cell <ks>(1,2)</ks>.
						<br/><br/>

						The proper scene for the WEnv is reported in: <a href="parkingAreaConfig.js" target="code">parkingAreaConfig.js</a>
					
						<center><img src="./img/parkingAreaZone.PNG" alt="parkingAreaZone.PNG" width="45%" height="32%"/></center>
					</li>
					<li>a <em>parking-manager</em> (an human being) which supervises the state of the <tt>parking-area</tt> and handles critical situation. </li>
				</ul>

				<div class="remark">
					The job of our company is to design, build and deploy the  <em>ParkManagerService</em>.
				</div>
				<h3>User stories</h3>
					As a <bc>client - parking phase</bc>:
					<ul>
						<li>
							I intend to use a <em>ParkServiceGUI</em> provided by the <tt>ParkManagerService</tt> to notify my interest in <i>entering</i> my auto in the <tt>parking-area</tt> and to receive as answer the number <em>SLOTNUM</em> of a  free parking-slot  (<tt>1&lt;=SLOTNUM&lt;=6</tt>). 
							<tt>SLOTNUM<k>==0</k></tt> means that no free slot is available.</em>
						</li>
						<li>
							If <tt>SLOTNUM <k>>0</k></tt>, I move my car in front to the <tt>INDOOR</tt>, get out of the car and afterwards press a <em>CARENTER</em> button on the 
							<em>ParkServiceGUI</em>. Afterwards, the <tt>transport trolley</tt> takes over my car and moves it from the <tt>INDOOR</tt> 
							to the selected <tt>parking-slot</tt>.
							The <tt>ParkServiceGUI</tt> will show to me a receipt that includes a (unique) <em>TOKENID</em>, 
							to be used in the <i>car pick up</i> phase.
						</li>
					</ul>
					As a <bc>client - car pick up phase</bc>:
					<ul>
						<li>I intend to use the <tt>ParkServiceGUI</tt> to submit the request to pick up my car, by sending the <tt>TOKENID</tt> previously received. </li>  
						<li>Afterwards, the <tt>transport trolley</tt>  takes over my car and moves it from its <tt>parking-slot</tt> to the <tt>OUTDOOR-area</tt>.</li>
						<li>I move the car, so to free the <tt>OUTDOOR-area</tt>.</li>
					</ul>
					As a <bc>parking-manager</bc>:
					<ul>
						<li>
							I intend to use the <em>ParkServiceStatusGUI</em>  provided by the <tt>ParkManagerService</tt>
							to observe the <em>current state</em> of the <tt>parking area</tt>, including the value <tt>TA</tt> of the temperature,
							the state of the <tt>fan</tt> and the state of the <tt>transport trolley</tt> (<k>idle, working or stopped</k>).
						</li>
						<li>
							I intend to <em>stop</em> the <tt>transport trolley</tt> when <k>TA > TMAX</k>, activate the <tt>fan</tt> and 
							wait until <k>TA &lt; TMAX</k>. At this time, I stop the <tt>fan</tt> and resume the behavior of the <tt>transport trolley</tt>.
							Hopefully, the <b>start/stop</b> <ks>of the fan</ks> could also be automated by the <tt>ParkManagerService</tt>,
							while the <b>start/stop</b> <ks>of the transport trolley</ks> is always up to me.
						</li>
						<li>
							I expect that the <tt>ParkManagerService</tt> sends to me an <em>alarm</em> if it detectes that the <tt>OUTDOOR-area</tt>
							has not been cleaned within the <tt>DTFREE</tt> interval of time.
						</li>
					</ul>
				<h3>Requirements </h3>
					The <tt>ParkManagerService</tt>  should create the <tt>ParkServiceGUI</tt> (for the client) 
					and the <tt>ParkServiceStatusGUI</tt> (for the manager) and then perform the following tasks:
					<ul>
						<hr/>
						<li id="acceptin">
							<em>acceptIN</em>: accept the request of a client to park the car if there is at least one <tt>parking-slot</tt> available, select a free slot identified with a unique <tt>SLOTNUM</tt>.<br/>
							A request of this type can be elaborated only when the <k><tt>INDOOR-area</tt> is free</k>, 
							and  the <tt>transport trolley</tt> is at <tt>home</tt> or working (<k>not stopped</k> by the manager). 
							If the <tt>INDOOR-area</tt> is already engaged by a car, the request is not immediately processed 
							(the client could simply wait or could - optionally - receive a proper notice). 
							<br/>
						</li>
						<li id="informin"><em>informIN</em>: inform the client about the value of the <tt>SLOTNUM</tt>.<br/>
							If  <k>SLOTNUM>0</k>:
							<ol>
								<li id="movetoin"><em>moveToIn</em>: move the <tt>transport trolley</tt> from its current localtion to the <tt>INDOOR</tt> ;</li>
								<li id="receipt"><em>receipt</em>: send to the client a receipt including the value of the <tt>TOKENID</tt> ;</li> 
								<li id="movetoslotin"><em>moveToSlotIn</em>: move the <tt>transport trolley</tt> from the <tt>INDOOR</tt> to the selected <tt>parking-slot</tt>;</li>
								<li><em>backToHome</em>: if no other request is present,  move the <tt>transport trolley</tt> to its <tt>home</tt> location, else <em>acceptIN</em> or <em>acceptOUT</em>.</li> 
							</ol>
							If <k>SLOTNUM==0</k>: 
							<ul>
								<li><em>moveToHome</em>: if not already at home, move the <tt>transport trolley</tt> to its <tt>home</tt> location.</li> 
							</ul>
						</li>
						<hr/>
						<li id="acceptout">
							<em>acceptOUT</em>: accept the request of a client to get out the car with <tt>TOKENID</tt>.
							A request of this type can be elaborated only when the <k><tt>OUTDOOR-area</tt> is free</k>
							and  the <tt>transport trolley</tt> is at <tt>home</tt> or working (<k>not stopped</k> by the manager).
							If the <tt>OUTDOOR-area</tt> is still engaged by a car, the request is not immediately processed 
							(the client could simply wait or could - optionally - receive a proper notice).
							<ol>
								<li id="findslot"><em>findSlot</em>: deduce the number of the parking slot (<em>CARSLOTNUM</em>) from the <tt>TOKENID</tt>;</li>
								<li id="movetoslotout"><em>moveToSlotOut</em>: move the <tt>transport trolley</tt> from its current localtion to the <tt>CARSLOTNUM/parking-slot</tt> ;</li>
								<li id="movetoout"><em>moveToOut</em>: move the <tt>transport trolley</tt> to the <tt>OUTDOOR</tt> ;</li>
								<li>
									<em>moveToHome</em>: if no other request is present  move the <tt>transport trolley</tt> to its <tt>home</tt> location; <br/>
									else <em>acceptIN</em> or <em>acceptOUT</em>
								</li>
							</ol>  
						</li>
						<hr/>
						<li id="authorize"><em>authorize</em>: allow a manager to use the ParkServiceStatusGUI only if she/he owns proper permissions.</li>
						<hr/>
						<li id="monitor"><em>monitor</em>: update the <tt>ParkServiceStatusGUI</tt> with the required information about the state of the system.</li>
						<hr/>
						<li id="manage"><em>manage</em>: accept the request of the manager to stop/resume the behavior of the  <tt>transport trolley</tt>.</li>
					</ul>
			<h2>Requirement analysis</h2>
				<h3>Domain Analysis: critical nouns and verbs definition</h3>
					<ul>
						<li><em>Software system</em>: system made of intercommunicating components based on software.</li>
						<li><em>DDR robot (a.k.a trolley)</em>: a real/virtual robot capable of moving in the four cardinal directions and sending/receiveing information. The robot will have a squared size of length RD and will start at its home. The robot could be in three states: idle, the robot waits for the next request (reception or restitution), working, the robot is transporting a car, stopped, the robot was stopped by the parking-manager.</li>
						<li><em>Parking area</em>: real/virtual empty room that includes two doors: one to enter the area, the other to exit it. There are also six available parking spots, a thermometer sensor to detect the parking area temperature and a fan.</li>
						<li><em>Indoor area</em>: entrance area of the parking area. It is equipped with a sensor that mesures the weight of a car.</li>
						<li><em>Outdoor area</em>: exit area of the parking area. It is equipped with a sonar that detects the presence of a car in the area.</li>
						<li><em>Map</em>: a map of the parking area which instructs on the position of the trolley, of the parking spots and the boundaries of the parking area. An example is available at: <a href="./parkingMap.txt"> parkingMap.txt</a>. Every cell of the map is of the same length of the robot and can be referenced to with a couple of numbers, e.g. (2,2).</li>
						<li><em>Trolley home</em>: a place in the upper left corner of the parking area. It is identified by the position (0,0) in the map.</li>
						<li><em>Parking manager</em>: a human responsible for the parking area. He should be able to check on the parking area status and handle possible critical situations.</li>
						<li><em>Client</em>: a human that want to park his/her car in the parking space and has to use our software system.</li>
						<li><em>Token</em>: a unique code that can identify the slot in which a certain car is parked in a specified instance of time.</li>
						<li><em>Stop the trolley</em>: send a stop message to the trolley to halt its behaviour. The behaviour can be later resumed with a resume message. The trolley cannot be stopped while on trip.</li>
						<li><em>Trip</em>: every movement of the trolley from the HOME position to the IN/OUTDOOR area and viceversa, from the INDOOR area to one of the parking slots or from the parking slots to the OUTDOOR area.</li>
					</ul>
				<h3>Schematized requirements</h3>
					<div class="remark">
						The requirements can be addressed in this document and the one who reference it by their identifier (requirement type, number of the requirement, e.g. F1 for functional requirement n.1, NF2 for functional requirement n.2, etc.). The product-owner specified requirements (e.g. informIN) can also be referred to as POR (Product Owner Requirement) and then the name of the requirement.
					</div>
					<h4>Functional requirements</h4>
						<ol class="fr">
							<li>The client should be made able to notify his/her interest to park his car on a free parking spot throught the ParkServiceGUI interface.</li>
							<li>Our system can accept a new client request only when the robot is in home position or is working and if the INDOOR area is free at the time of the request. Conversely the system should notify the client to wait.</li>
							<li>The client should be notified if no parking spot is free. Conversely he should receive the number of the chosen parking slot if available.</li>
							<li>The client should be made able to notify the system when he has left his/her car in the indoor area.</li>
							<li>Our system should instruct the trolley to escort a car from the indoor area to the specified parking slot.</li>
							<li>When a car is parked, our system should be able to produce a unique token and send it to the client throught the ParkServiceGUI in order to identify the parking slot from which a certain car should be picked up when its owner returns.</li>
							<li>The client should be made able to pick up his/her car by providing the token acquired after the parking.</li>
							<li>Our system should be able to infer the parking slot of the car to be picked up from the token.</li>
							<li>Our system should instruct the trolley to collect the car specified by the client-provided token from its parking slot and take it to the outdoor area.</li>
							<li>Our system should communicate with the parking manager throught the ParkServiceStatusGUI interface.</li>
							<li>Our system should be able to notify the parking manager if the car has not been picked up from the outdoor area in a given interval of time.</li>
							<li>Our system should be able to collect state information from the parking area (via the sensors and thermometers) such as the temperature and the state of the fan.</li>
							<li>Our system should be able to collect state information from the trolley (idle, working, stopped).</li>
							<li>The parking manager should be made able to stop the trolley when the temperature of the parking area reaches a certain limit. When the temperature returns under the limit the manager should be able to resume the behaviour of the trolley.</li>
							<li>Our system should be able to start/stop the fan when the temperature reaches or leaves a certain limit.</li>
							<li>Our system should identify and authenticate the parking manager before letting him access the system.</li>
							<li>Our system should be able to double-check the client statement of having his car parked in the INDOOR area through the weight sensor.</li>
						</ol>
					<h4>Non functional requirements</h4>
						<ol class="nfr">
							<li>It should be difficult for a client to forge the unique token to collect a car that is not his/hers.</li>
							<li>The trolley should be able to update the map of the parking area with its current position at all times.</li>
							<li>The trolley cannot walk on the parking slots.</li>
							<li>The robot can manage one request at time and it can be stopped only by the parking manager.</li>
							<li>The robot is available only when it is in the home position or when it is in the working state.</li>
							<li>The robot should not transporting a car to the outdoor area if this is not free.</li>
							<li>When the robot is in the idle state it should be return to the home position.</li>
						</ol>		
				<h3>Use cases</h3>
					<h4>Client use cases</h4>
						As a <ks>client</ks> I expect to be able to:
						<h5>Parking Phase</h5>
							<ul>
								<li> Request the need of parking my car by accessing the ParkServiceGUI. This request must be accepted if there is at least one <tt>parking slot</tt> available, the INDOOR area is free and the robot is not stopped by the manager as per POR <a href=#acceptin><em>acceptIN</em></a>
								<li> Be informed about the SLOTNUM chosen by the system that refers to the parking slot where my car will be parked or that there is no space for my car to be parked at the moment as per POR <a href=#informin><em>informIN</em></a>.</li>
								<li> If the returned SLOTNUM is a positive integer, after correctly parking my car in the INDOOR area and notify the system of this event, I expect also for my car to be collected from the INDOOR area (POR <a href=#movetoin><em>moveToIn</em></a>) and parked in the right parking spot (POR <a href=#movetoslotin><em>moveToSlotIn</em></a>) as well as receiving a TOKENID to be used in the car pickup phase (POR <a href=#receipt><em>receipt</em></a>)</li>
							</ul> 
						<h5>Car Pickup Phase</h5>
							<ul>
								<li> Request the need to collect my parked car presenting to the ParkServiceGUI the TOKENID obtained in the car parking phase. This request must be accepted if the OUTDOOR area is empty and the trolley is not stopped by the manager, as per POR <a href=#acceptout><em>acceptOUT</em></a></li>
								<li> If the token provided by me is valid, I also expect that the system automatically infers the correct parking slot of my car from the token (POR <a href=#findslot><em>findSlot</em></a>) as well as my car being transported by the trolley on the OUTDOOR area (PORs <a href=#movetoslotout><em>moveToSlotOut</em></a> and <a href=#movetoout><em>moveToOut</em></a>)</li>
							</ul>
					<h4>Parking Manager use cases</h4>
						As the <ks>parking manager</ks> I expect to be able to:
						<ul>
							<li>Be informed on the updated state of the parking area and system by the ParkServiceStatusGUI (POR <em class="al">monitor</em>)</li>
							<li>Stop/Resume the behavior of the trolley from the ParkServiceStatusGUI (POR <em class="al">manage</em>)</li>
							<li>Being identified and authenticated by the system (POR <em class="al">authorize</em>) before letting me perform any of the above actions</li>
						</ul>
				<h3>Third party software</h3>
					The product owner has provided us with a plethora of already developed software and components ready to use.<br>
					Specifically, we aknowledge that the parking area can be modeled as a properly simulated space in a <k>virtual environment</k>. This can be helpful for prototype developement, as well as punctually create a model to be used to develop the first working instances of our application.
					The virtual environment <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/master/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html"> WEnv</a> is provided by the customer and can be easily
					configured by the application designer and an example that matches our requirements is available at <a href="./parkingAreaConfig.js">parkingAreaConfig.js</a>.<br/>
					A <k>robot simulation</k> is also available in the WEnv; details on how to communicate with this virtual component can be found in the <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/master/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html#interaction">virtual robot section</a>.<br/>
					A <k>robot instructor</k> is provided in the form of the <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html">BasicRobot</a> component.
					This is an observable kotlin actor which is already well integrated with the WEnv service and has the capability of communicating in a high level message-based way both with HTTP and WS protocols, both supported by the WEnv, which expose the 8090 port to accept HTTP requests and the 8091 port to accept synchronous/asynchronous messages via WS. 
					Finally, the product owner also provides us a <k>custom modelling language (DSL) and metamodel</k>, the <a href="https://htmlpreview.github.io?https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/userDocs/LabQakIntro2021.html" >QAKactor metamodel</a>. This helps building a model of the system exploiting actors technology, as a substitute for the usual object technology, to achieve 
					high-level interaction between components, as the actors possess an inward message queue which can be used to communicate with a specific message-based application level protocol, which sits on top of the usual, most used transport and application level protocols (HTTP, WS, TCP, UDP, etc.). 
				<h3>Early phase model of the requirements</h3>
					A first, embrional model of the system can be derived by the atop requirements, and can be found in <a href="">requirementModel.qak</a>
				<h3>First test plan ideas</h3>
					<ul>
						<li><em>moveToIn</em>: check on the map if the position of the trolley corresponds with the indoor area (6,0) (<lr>F5</lr>)</li>
						<li><em>moveToSlotIn/Out</em>: check on the map if the position of the trolley is adjacent to the chosen parking spot (e.g. (3,2) if the parking slot is (3,3)) (<lr>F5</lr>-<lr>F9</lr>)</li>
						<li><em>backToHome</em>: check on the map if the trolley has returned home (0,0) (<lr>NF7</lr>)</li>
						<li><em>moveToOut</em>: check on the map if the position of the trolley corresponds with the outdoor area (6,4) (<lr>F9</lr>)</li>
						<div class="remark">
							<k>Carefully note</k> that in every test above, one should also check if the robot behaves correctly (e.g. doesn't walk on the parking slots as per <lr>NF3</lr>, etc.) also by checking its route on the map 
						</div>
						<li>Check that if there are no available parking slots the system doesn't accept the request (<lr>F3</lr>)</li>
						<li>Check that if a client specifies a wrong token the system does not accept the request and that the system does not give back the wrong car (<lr>F6</lr>-<lr>F7</lr>-<lr>F8</lr>)</li>
						<li>Check that the parking manager can access the parking area information only if authenticated (<lr>F10</lr>-<lr>F16</lr>)</li>
						<li>Check that if the parking manager stops the robot, it immediately stops and no other task is executed by the trolley until it exits the stop state (<lr>F14</lr>-<lr>NF4</lr>-<lr>NF5</lr>)</li>
						<li>Check that if TA > TMAX the fan starts and viceversa (<lr>F15</lr>)</li>
						<li>Check that a correct notification is sent to the parking manager if a car remains in the OUTDOOR area for more than DTFREE time (<lr>F11</lr>)</li>
						<li>Check that the trolley does not pick up a car from the INDOOR area, if the client says there's a car but no confirmation arrived from the weight sensor (<lr>F17</lr>)</li>	
					</ul>
					<div class="remark">
						These tests should all be implemented in the subsequent sprints, as are envisioned by the analysts to be the most basic functional tests given the requirements. Other useful tests may be developed as well.
					</div>
			<h2>Problem Analysis</h2>
				<h3>Main problems</h3>
					<h4>Components</h4>
						
						<div class="remark">
								<k>NOTE THAT</k> even though we are working in a virtual environment and with virtual components, this should be done with a fair amount of abstraction that insures 
								some sort of <bc>technology indipendence</bc>; this would help an hypothetical subsequent phase in which the simulated components will be replaced by real ones,
								by not changing the business logic. This could be achieved by developing proper interfaces as well as a high level interaction protocols and architectures between components.
						</div>
						
						<h5 id="trolleyFSM">Trolley</h5>
							Our job is to design and develop a component that communicates with the virtual robot and instructs it properly to match our system's needs.  <br/> 
							By requirements, this "trolley" should have 3 states that match the actual state of the robot: <k>idle</k>, <k>working</k> and <k>stopped</k>. The possible state transitions and details are presented in the coming state diagram.
							
							<td style="width:50%">
								<center><img src="./img/TrolleyFSM.png" width="70%"></center>
							</td>

							If the trolley is both in the <k>working</k> or the <k>stopped</k> state and new client requests arrive, the trolley should be able to <tt>queue</tt> them in order to start a new job related to the new request once the current one is concluded. <br/> 
							Given the way the problem has been mapped, the <k>idle</k> state was deemed by the analysts to describe both the robot presence and the returning in its home position to allow the trolley to accept incoming request by the client immediately. In fact, if the returning to home task was mapped as <k>working</k> state, the trolley should have been completing the returning to home task first and then start working on the new request, which was found a less efficient behaviour.   
							Since its behaviour can be stopped and resumed, the trolley should also save what task was he completing or what task should have it have been completing next. After a meeting with the product owner, having presented him the issue, we agreed that 
							this problem can be faced by stopping a trolley only once a task is completed: it can then resume its behaviour from the earliest message it received by inspecting its message queue.
							<div class="remark">
								In developing our trolley, an actor implementation could be preferred above an object one as they implement a message based type of concurrency which satisfy the demand for a high level interaction between componenets and relieves the developer of handling thread safety, as well as reducing the number of threads to be used in the system. It also natively presents a message queue which is useful to our needs.<br>
							</div>
						<h5>Main service</h5>
							The <tt>ParkManagerService</tt> should contain the biggest part of the <tt>business logic</tt>, as it is the main controller of the system. It should be able to communicate with all the components in the system to be informed about their state, react to all the events that could happen in accord to the requirements and present the results of its actions to the user interfaces.
							It also should mantain the system state in a configuration file to be uploaded at the system's startup: in this way the system will be highly configurable without having to rely on "initial conditions" and will also be fault tolerant. The system state representation and persistance/collection will be discussed later.
						<h5>User interfaces</h5>
							There should be two types of user interfaces:
							<ul>
								<li>The <tt>ParkServiceGUI</tt> has to accept client interactions and communicate with the main service to accomodate the client needs if possible</li>
								<li>The <tt>ParkServiceStatusGUI</tt> has to accept the parking manager interactions (e.g. to stop/resume the trolley) and present to him/her the system state</li>
							</ul>
						<h5>Sensors and fan</h5>
							Since we are working in a virtual environment and there are no specific component already available, <tt>sensors</tt> (e.g. weight sensor, thermometer, etc.) and <tt>fan</tt> can be <k>simulated</k> too.<br/>
							So, our job is to design and develop these components and allow them to communicate with the main service.<br/>
							
							Regarding the sonar:
							<ul>
								<li>a TCP-based sonar-data simulator is defined in <a href="https://raw.githubusercontent.com/anatali/issLab2021/master/it.unibo.issLabStart/resources/jupyter/sonarResourceCallerTCP.ipynb">sonarResourceCallerTCP.ipynb</a>;</li>
								<li>a MQTT-based sonar-data simulator is defined in <a href="https://raw.githubusercontent.com/anatali/issLab2021/master/it.unibo.issLabStart/resources/jupyter/sonarResourceCallerMQTT.ipynb">sonarResourceCallerMQTT.ipynb;</a></li>
								<li>a CoAP-based sonar-data simulator is defined in <a href="https://raw.githubusercontent.com/anatali/issLab2021/master/it.unibo.sonarAsResource/javacode/coap/SimulateSonarData.java">SimulateSonarData.java</a></li>
							</ul>
							A possible receiver of the sonar-data is described in the <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/master/it.unibo.sonarAsResource/userDocs/LabSonarAsResource.html">"resource" section of LabSonarAsResource.html</a>; this can also be used as an <k>observable resource</k> to let the main service receive the sonar information indirectly.<br>
							A similar approach can be undertaken for every other sensor in the system, but the final decision is left to the designers. <br>
							The fan can also be treated as the other sensors but, as an actuator, should present some function or method to be activeted/deactivated when needed. 
					<h4>Interaction</h4>
						<!--TODO: A table may be clearer-->
						From the communication standpoint, the problem as a whole demands an hybrid approach: if some requirements (e.g. F1,F2,F3, etc.) ask for a <k>synchronous</k> approach, some others could benefit from an <k>asynchronous</k> one (e.g. firing an event, as per requirement F11).
						Moreover, some PORs (acceptIN/OUT, monitor) also require for the components' state to be known by an external object/actor. This could be either done with a synchronous request to the component, by <tt>making its state <kc>observable</kc></tt> or by
						<tt><kc>publishing</kc> its state to a resource</tt> every time the state changes, so that every entity subscribed to that topic can receive the information asynchronously.<br/>
						The first option is not always ideal, as the component could be busy at the time of the request or it cannot afford to be stopped to supply the reply. The third approach requires the presence of a third entity to publish on/subscribe to.
						<br>For the <tt>synchronous interaction</tt>, the <kc>HTTP protocol</kc> is ideal as the virtual robot we proposed already support HTTP requests on port 8090; for the same reason, the <kc>websocket protocol</kc>
						can be used for handling the <tt>asynchronous</tt> demands, on port 8091 for the robot (as stated in <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.wenvusage/userDocs/VirtualRobot2021.html#commands">virtual robot commands</a>). Both protocols should be handled by a proper support entity that can be used by all components relieving them from the burden of handling the communication themselves. An example of this can be found at <a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.kotlinSupports/app/src/main/kotlin/it/unibo/supports/IssWsHttpKotlinSupport.kt">IssWsHttpKotlinSupport.kt</a><br/>
						For what concerns the other <tt>M2M interactions</tt> and the observable states, the <kc>CoAP protocol</kc> is widely used in IoT and embedded world as it is a very lightweight but powerful protocol, but also <kc>MQTT</kc> brokers can be used to implement a publish/subscribe pattern.
					<h4><em>Sprint review 1</em>: State representation and persistance</h4>
						As per our requirements, we need the <em>ParkManagerService</em> to mantain the state of different resources:
						<ul>
							<li><tt>Parking slots</tt> free/engaged</li>
							<li><tt>TOKENID</tt> of the parked cars</li> 
							<li><tt>Fan</tt> working/stopped</li>
							<li><tt>Trolley</tt> state</li>
							<li><tt>Robot position</tt></li>
							<li><tt>Weight Sensor</tt> data</li>
							<li><tt>Temperature</tt> value</li>
							<li><tt>Sonar</tt> data</li>
						</ul>
						Considering our analysis so far, we advise the designers to keep the trolley, sensors and fan state distributed and available when needed to the ParkManagerService. The parking slots state, however, can be
						retained in a centralized manner by the service:  it will be responsible of the slots' state management and change as the requirements dictate.<br>
						Regarding the <tt>slots' state</tt>, it could be modeled in a number of ways; we suggest two solutions, but pass on the choice to the designers:
<pre>
<tt>/* </tt><k>First choice: a boolean array</k>
 <tt>* In this case, the index of the array would represent the SLOTNUM-1
 * while the cell value would represent free->true, engaged->false
 * The TOKENID could also be mapped as the SLOTNUM itself for simplicity
 * This is a quick solution, maybe fit for prototype purposes
 */</tt>
var slotStateFree: BooleanArray = booleanArrayOf(false, false, false, false, true, false)
<tt>/* </tt><k>Second choice: map</k>
 <tt>* In this case, the key of the map would represent the SLOTNUM
 * while the value would contain the TOKENID value if the parking slot is engaged, an empty value otherwise
 * This is a more expressive solution, also keen to a more complex representation of the TOKENID
 */</tt>
var slotState = mutableMapOf(1 to "TOKENID1", 2 to "empty", 3 to "TOKENID3", etc.)
</pre>
				Sensors and fan states can be easily represented as integers or strings, as the designer deem best. In this case, we assess that the weight sensor and sonar states could be retrieved
				using a polling strategy and a request/response patter, as these information are needed in specific and fixed moments in time (when the service wants to know if the in/outdoor area is free and to check that the client has really parked a car in the indoor area after his notification).
				The temperature, state of the fan and trolley, however, are required when the manager desires: we can predict when this event will happen. For this reason, we advise this resource to be made observable by the main service indirectly and without having to send a blocking request to the resources. How to implement this behaviour is a design matter.<br>
				Finally, some sort of state persistance for the centralized information should be implemented: we assess that a simple file could be of assistance. The file should contain the state information of the parking slots and the tokenid related to the engaged ones. An example is the following:
<pre>
<tt>/*
 * Parking slot/tokenid states could be saved in a json format
 * The internal state of the service could be reinstated by properly parsing this file
 * and building a proper internal representation from its infomation
 * This could be used as a initial state of the system or a fault-tolerance mechanism
 */</tt>
[
	{
		"slotnum":"1"
		"tokenid":"tokenid1"
	},
	{
		"slotnum":"2"
		"tokenid":"empty"
	},
	{
		"slotnum":"3"
		"tokenid":"tokenid3"
	},
	{
		"slotnum":"4"
		"tokenid":"empty"
	},
	{
		"slotnum":"5"
		"tokenid":"empty"
	},
	{
		"slotnum":"6"
		"tokenid":"tokenid6"
	}
]
</pre>
				The problem of the TOKENID representation is another difficult one: it should both convey the SLOTNUM information and be secure, unique and unforgeable. An example to satisfy all these requirements would be:
<pre>
<tt>/*
 * This solution presents the SLOTNUM as first argument to be easily parsed and 
 * attaches to it the date and time of the car enter request to make it unique
 */</tt>
&ltSLOTNUM&gt-&ltREQUESTDATETIME&gt
</pre>			
				Position information regarding the robot will be retained in a map of the parking area. Our trolley component should be able to update this map with his position every time it ends a trip. The map state should also be saved in a file for the same reasons as the parking slots' state.
				Finally, the trolley should also save its state in a file for the same reasons.
				<h3>Technologies and architectures</h3>
					An object oriented programming language, as Kotlin or Java, seems the best fit to implement the services of our system. Kotlin would be preferred for its native support for coroutines and actors that would benefit developers by not having to import many libraries and
					dependencies and, of course, in terms of resources, as coroutines are more lightweight than threads and don't need many expensive context swiches.<br/>
					To present results and prompts both to the client and the manager, some sort of GUI is mandatory. For this, an <tt>MVC pattern</tt> could help the observance of the single responsibility principle. To exploit code automation and boost developing times, Springboot can be used to
					automatically generate some boilerplate code for the construction of the MVC pattern and the GUI for our clients.<br/>
					In case of CoAP protocol usage, the californium library for java/kotlin can be a good choice for its renowned use in IoT environments and IETF usage for the standardization of the CoAP protocol.<br/>
					<div class="remark">
						Libraries that allow the means of communication required by the system are common in many high-level 
						programming languages;  this fact, united with the possibility to exploit the qak metamodel and the Actor component provided by the prodcut owner, implies that <k>no abstraction gap</k> on the communications side is identified. An abstraction gap is found on the 
						functional/testing side, as our system has no clue on where the trolley is in the virtual/real space at all times and on how to create a sequence of actions to move to robot from point A to point B: this is crucial to our system's functions
						and with regard to our first testing plan ideas.
						The choice of which language to use is delegated to the project phase but, indipendently on the choice, 
						some form of design pattern should be used to ensure <k>maximux abstraction</k> between the business logic and 
						the communication protocols used</k> (to grant reusability and possibility to change communication protocol if needed).
					</div>
				<h3>Logic Architecture</h3>
					For the symbols used in this document and the one that reference it, please refer to the following key<br/>
					<td style="width:50%">
						<center><img src="./img/legenda.png" width="30%" height="30%"></center>
					</td>
					<div class="remark">
						<center><k>THE COMING FIGURE DOES NOT REPRESENT THE CONCRETE SYSTEM, THAT WILL BE DEFINED IN THE PROJECT PHASE</k></center> 
					</div>
					<td style="width:50%">
						<center><img id="archLogica" src="./img/ArchitetturaLogica.png" width="70%"></center>
					</td>			
					As a result of the analysis phase, the system could be modelled as the above figure and could consist in:
					<table style="width:98%">
						<tbody>
						<tr><td>  
							<center><img src="./img/ParkManagerService.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>ParkManagerService</h4>
							<ul>
								<li>Service that holds the business logic to reply to the users requests by using all the other components in the system</li>
								<li>Communicates with 3 Browsers (two ParkServiceGUI and one ParkServiceStatusGUI) with a request/response pattern implementing a client/server architecture with the ParkService/ServiceStatusGUIs</li>
								<li>Communicates with the Trolley using dispatches</li>
								<li>Communicates with the WeightSensorInterface and the SonarController with a request/response pattern to obtain their data</li>
								<li>Accepts dispatches from the Sensors controllers when something irregular happens (e.g. TA > TMAX, car in the outdoor area for more than DTFREE. etc.)</li>
								<li>Sends a dispatch to the fan when it needs to be started/stopped</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/Trolley.png" width="60%"></center>
						</td><td style="width:80%">
							<h4 id="TROLLEY">Trolley</h4>
							<ul>
								<li>Actor observable by the ParkManagerService</li>
								<li>Holds the business logic to implement the trolley states</li>
								<li>Instructs a real/virtual robot on how to move via request/response and/or fire and forget pattern</li>
								<li>Uses/Updates a map of the area to deal with the robot position</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/ParkServiceGUI.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>ParkServiceGUI</h4>
							<ul>
								<li>Object that implements a view for the clients for both the in/outdoor areas</li>
								<li>Takes client inputs and sends relative requests to the ParkManagerService</li>
								<li>Present results of business logic tasks</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/ParkServiceStatusGUI.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>ParkServiceStatusGUI</h4>
							<ul>
								<li>Object that implements a view for the parking manager</li>
								<li>Takes parking manager inputs and sends relative requests to the ParkManagerService</li>
								<li>Presents the system state arrived from the ParkManagerService</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/ThermometerController.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>ThermometerController</h4>
							<ul>
								<li>Object with runnable thread which monitors the thermometer's data</li>
								<li>Observable by the ParkManagerService</li>
								<li>Sends a dispatch to the ParkManagerService if the temperature raises above TMAX</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/SonarController.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>SonarController</h4>
							<ul>
								<li>Object with runnable thread which monitors the sonar's data</li>
								<li>Sends a dispatch to the ParkManagerService if a car remains for more than DTFREE seconds in the outdoor area</li>
								<li>Replies to ParkManagerService requests for sonar's data</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/Fan.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>Fan</h4>
							<ul>
								<li>Object that mocks a fan</li>
								<li>Observable by the ParkManagerService</li>
								<li>Starts/stops after a dispatch arrives from the ParkManagerService</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/WeightSensorInterface.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>WeightSensorInterface</h4>
							<ul>
								<li>Object that monitor a weight sensor's data</li>
								<li>Replies to ParkManagerService requests for weight sensor's data</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/Fan.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>Fan</h4>
							<ul>
								<li>Object that mocks a fan</li>
								<li>Observable by the ParkManagerService</li>
								<li>Starts/stops after a dispatch arrives from the ParkManagerService</li>
							</ul>
						</td></tr>
						<tr><td>  
							<center><img src="./img/Map.png" width="60%"></center>
						</td><td style="width:80%">
							<h4>Map</h4>
							<ul>
								<li>Object that implements a map of the real/virtual room</li>
								<li>Offers method to read/update the map</li>
								<li>A possible implementation is found in <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.kotlinSupports/app/src/main/kotlin/mapRoomKotlin/RoomMap.kt">roomMap.kt</a></li>
								<li>An object that uses a map to instruct the robot with is available at <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.planner20/resources/itunibo/planner/plannerUtil.kt">plannerUtil.kt</a><br/></li>
							</ul>
						</td></tr>
						</tbody>
						
					</table>
					The logic architecture is deliberately vague about the nature of the Robot component, to abstract concepts and not constrain the analysis to a single implementation. If we wanted to delve in the virtual enviroment case, exploiting the product owner software, the Robot component should be replaced by the WEnv (which also holds the virtual robot component).<br>
					Talking about the trolley component, could be useful to split it in two sub-components to separate the buisness logic and communication patterns of the trolley with the main service from the "robot instructor" logic. This will grant decoupling of components, as well as reusability; the afore mentioned BasicRobot component could be also used to implement the robot instructor.<br>
					As a matter of fact, the Basic Robot can be also easily configured to work with diverse real robots as well as the virtual one, which satisfies the needs of abstraction already specified earlier in the analysis phase. Moreover, some of the functionalities that comes with this component can actually <tt>fill the abstraction gap</tt> identified in the analysis phase:
					the BasicRobot has the ability to move by "steps" of the same length as the robot. This would allow the robot to also create and interact with a virtual map in which each cell is of the same leght as the step and the robot itself (so that every step would result in a one-cell movement).
					<div class="remark">
						<k>Carefully note</k> that the term "observable" is here used to express the need of accessing some information without waiting for or stopping the observed entity. How this should be 
						implemented is a project matter (restful CoAP resource, publish/subscribe, etc.).
					</div>
					Communication between sensors and their controllers are described as <em>Events</em> because the sensors should not know the receiver of their messages; instead they should only fire an event to some not well defined entity that is interested in knowing what they have to say.<br/>
					The communication between the main service and the trolley and controllers, however, is described as a <em>Dispatch</em>: in this case both entity know each other and their "positions" and can communicate with themselves. The asynchronous manner seemed best for the problem, but designers are free to change this if they deem best.
			<h2>Sprint Planning</h2>
				After talking with the product owner and the development team we decided to divide the work in <k>4 Sprints</k>. Every sprint is relative to one or more PORs, to better identify their goals with a terminology which is understandable both to the product owner and scrum team.<br/>
				The first 3 sprints are relative to the client user stories/use cases so that a deliverable subsystem should be ready for deployment as soon as possible. Furthermore, the sprint order is thought to boost the development time by designing and developing <tt>bigger components first</tt>, that can be then reused in the coming sprints.<br>
				The last sprint would close up the project by terminating the deliverable software relative to the parking manager user stories/use cases, deemed less crucial from the product owner perspective.
				<h3 id="sprint1">SPRINT 1</h3>
					This sprint is relative to the POR <a href="#informin"><em>informIN</em></a>, divided into F3, F4, F5, F6, F17, NF1, NF2, NF3, NF7 by the analysts.
					<table class="sprint">
						<thead>
							<tr>
								<th>Must Have</th>
								<th>Should Have</th>
								<th>Could Have</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									The client must be informed if no parking slots are available at the time of his request (<lr>F3</lr>)<br>
									The ParkManagerService must successfully instruct the robot on how to move; in particular, the robot must be moved from the INDOOR AREA to one of the Parking Slots (<lr>F5</lr>)<br>
									A unique token must be successfully generated and presented to the client (<lr>F6</lr>)<br>
									The system must aknowledge from the client when the car is in the INDOOR area and double-check this fact through the weight sensor(<lr>F4</lr>-<lr>F17</lr>)
								</td>
								<td>
									The map should be updated with the movements of the robot (<lr>NF2</lr>)<br>
									The robot should not walk over the parking slots (<lr>NF3</lr>)<br>
									The robot should correctly return to the home position if idle (<lr>NF7</lr>)
								</td>
								<td>The ParkServiceGUI is supposed to show a prompt for the client to interact with to notify to the system that the car has been placed in the INDOOR area (<lr>F4</lr>)
									The token is supposed to be unique and unforgeable (<lr>NF1</lr>)</td>
							</tr>
						</tbody>
					</table>
					This sprint should be done in <k>one week</k>.
				<h3 id="sprint1">SPRINT 2</h3>
					This sprint is relative to the POR <a href="#acceptout"><em>acceptOUT</em></a>, divided into F2, F7, F8, F9, NF2, NF3, NF5, NF6, NF7 by the analysts.
					<table class="sprint">
						<thead>
							<tr>
								<th>Must Have</th>
								<th>Should Have</th>
								<th>Could Have</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									The robot must accept a client request if it is available (<lr>F2</lr>-<lr>NF5</lr>)<br>
									The client must successfully submit a TOKENID to begin the car collect phase (<lr>F7</lr>)<br>
									The system must correctly infer the parking slot from the provided token (<lr>F8</lr>)<br>
									The system must successfully instruct the trolley to reach the correct parking slot, collect the car and bring it to the OUTDOOR area (<lr>F9</lr>)
								</td>
								<td>
									The map should be updated with the movements of the robot (<lr>NF2</lr>) <br>
									The robot should not walk over the parking slots (<lr>NF3</lr>) <br>
									The robot should correctly return to the home position if idle (<lr>NF7</lr>)
								</td>
								<td>
									The system is not supposed to instruct the robot to move the car from the parking slot to the OUTDOOR area if it is already occupied by a car (<lr>F6</lr>)<br>
									The ParkingServiceGUI is supposed to show a prompt to the client for him to submit the token (<lr>F7</lr>)
								</td>
							</tr>
						</tbody>
					</table>
					This sprint could leverage and reuse some components created in the previous sprint so <k>four days</k> should be enough.
				<h3 id="sprint1">SPRINT 3</h3>
					This sprint is relative to the POR <a href="#acceptin"><em>acceptIN</em></a>, divided into F1, F2, NF5 by the analysts.
					<table class="sprint">
						<thead>
							<tr>
								<th>Must Have</th>
								<th>Should Have</th>
								<th>Could Have</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									The client must successfully submit a parking request (<lr>F1</lr>)<br>
									The service must accept a request if the INDOOR area is free (<lr>F2</lr>) <br>
									The robot must accept a client request if it is available (<lr>F2</lr>-<lr>NF5</lr>)<br>
								</td>
								<td></td>
								<td>The ParkServiceGUI is supposed to show a prompt for the client to interact with for his parking request (<lr>F1</lr>)</td>
							</tr>
						</tbody>
					</table>
					This sprint should conclude the client use cases and could result in a deliverable and deployable subsystem. This should be done in two day.
				<h3 id="sprint4">SPRINT 4</h3>
					This sprint is relative to the PORs <em class="al">authorize</em>, <em class="al">manage</em>, <em class="al">monitor</em>, divided into F10, F11, F12, F13, F14, F15, F16, NF4 by the analysts.
					<table class="sprint">
						<thead>
							<tr>
								<th>Must Have</th>
								<th>Should Have</th>
								<th>Could Have</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									The system must notify the parking manager if the car has not been picked up from the outdoor area (<lr>F11</lr>)<br>
									The system must collect state information from the parking area (temperature, fan) (<lr>F12</lr>)<br>
									The system must collect state information from the trolley (<lr>F13</lr>)<br>
									The parking manger can stop the trolley when the temperature of the parking area reaches a certain limit (<lr>F14</lr>-<lr>NF4</lr>)<br>
									The system must start/stop the fan when the temperature reaches or leaves a certain limit (<lr>F15</lr>)
								</td>
								<td>The system should identify and authenticate the parking manager (<lr>F16</lr>)</td>
								<td>The ParkServiceStatusGUI is supposed to show a prompt to the parking manager to manage and monitor the system (<lr>F10</lr>)</td>
							</tr>
						</tbody>
					</table>
				This sprint should end the development cycle and should be done in <k>5 days</k>.
			<h2>First executable model</h2>
				Before starting with the design and production, a working prototype can be useful to begin laying down some functional test plans and to show the product owner our understanding of (part of) the requirements in a more disambiguous way and test out our analysis . To do so, an executable model of our domain should be designed. <br>
				We will achieve this with the help of the afore mentioned QAK Metamodel, that will help creating a smaller executable version of our domain model in which every component will be substituted by actors communicating with each other and executing tasks by the means of a Moore's Finite State Machine.<br>
				An overview of the architecture used in this section is the following:
				<div class="remark">
					<center><k>THE COMING FIGURE IS A SEMPLIFICATION OF THE SYSTEM WE SHOWED IN THE ANALYSIS PHASE</k></center> 
				</div>
				<td style="width:50%">
					<center><img id="execModel" src="./img/ModelloEseguibile.png" width="70%"></center>
				</td>
				The full code of the executable model is available at <a target="code" href="../src/parkingArea.qak">parkingArea.qak</a><br>
				As one can see in the image, we decided to simplify the initial system model by removing the sensors and the fan, and focusing only on the client-service-trolley interaction which makes up for the most funtions of the system. No real trolley instructor or robot has been introduced in this model,
				rather we decided to focus on the high-level behaviour of the components (implement the trolley states, the messages between the users and the service, etc.)<br>
				The system was mapped as 1 qakactor for the trolley, 2 qakactors for the main service, 3 qakactors for the clients (one to simulate a client who wants to park a car, one to simulate a client who wants to pickup a car and one to simulate the manager). <br>
				Finally, to store some utility information, we decided to include a shared knowledge base between all components, implemented as a simple object. It should also be useful during the testing phase to quickly change some system parameters to observe the system's behaviour in diverse scenarios.<br>
				<div class="remark">
					<k>Carefully note</k> that this new model of the system is not very far from the logic architecture we introduced earlier: the logic architecture better seizes the true nature of the components (as per the analysis we conducted), but this first executable model can be of use to begin designing and developing sprint1.
				</div>
			<h2 id="tests">Test Plan</h2>
			Before beginning the test plan we realized that, for the qak system to be fully working and testable, we needed some way to synchronize the tests and the actors of the qak model. This is because, once a qak context is run, every actor inside it starts at the same time and there are no way to implement unit test or to test one functionality at the time. To achieve this goal we introduced a "listening" state on every actor we intended to test: this state is empty and it consists in waiting for a proper message to trigger a specific state change; 
			in this way, we can systematically and sequentially trigger states to test by sending messages both from the testing class and other actors, to perform integration tests. This "listening" state should be engaged at an actor startup and every time it ends a task. <br>
			Since qakactor are natively a CoAP-observable resources, we also thought to utilize a CoapObserver for each qakactor we wanted to observe for testing purposes. Its code is available at <a href="../test/it.sembrava_qualcuno.unibo.tf21Start/CoapObserverForTesting.kt">CoapObserverForTesting.kt</a><br>
			Finally, we divided our tests into unit tests and integration tests that also coincide with functional tests (as they test specific requirements or use cases).
			
			<h3>Unit tests</h3>
				For all the tests we assumed these starting conditions:
				<ul>
					<li>The trolley is not stopped by the manager</li>
					<li>The INDOOR is not engaged</li>
					<li>The OUTDOOR is not engaged</li>
					<li>There is one free parking slot</li>
				</ul>
				These conditions were individually changed by the single tests if they needed some other context, as described below. 
				<h4>Trolley</h4>
				Test code can be found at <a trget="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/TrolleyUnitTest.kt">TrolleyUnitTest.kt</a><br>
				<ul>
					<li>Test if the trolley returns in idle state at the end of a task</li>
					<li>Test the ability of the trolley to queue requests in case one arrives during the execution of a task</li>
					<li>Test if the trolley goes to stopped state immediately after it ends a trip, in case he is in working state and a stop event arrives. Test also if, once a resume event arrives, it returns to the working state</li>
					<li>Test if the trolley immediately goes to stopped state in case he is in idle state and a stop event arrives. Test also if, once a resume event arrives, it returns to the idle state</li>
					<li>Test if once the trolley is in stopped state, whatever request arrives it continues to stay in the stopped state, unless a resume event arrives</li>
				</ul>
				<h4>ClientService</h4>
					Test code can be found at <a trget="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/ClientServiceUnitTest.kt">ClientServiceUnitTest.kt</a>
					<ul>
						<li>Test that a client request to park a car (<k>requenter</k>) doesn't continue if the INDOOR area is not free (<k>enter</k> reply give back SLOTNUM=0, no subsequent <k>carenter</k> request, instead I expect a goToWork dispatch)</li>
						<li>Test that a client request to park a car (<k>requenter</k>) doesn't continue if there are no free parking slots available (<k>enter</k> reply give back SLOTNUM=0, no subsequent <k>carenter</k> request, instead I expect a goToWork dispatch)</li>
						<li>Test that if the trolley is stopped (infer this using the Knowledge base), every request is discarded (<k>enter</k> reply give back SLOTNUM=0, no subsequent <k>carenter</k> request, instead I expect a goToWork dispatch)</li>
						<li>Test that after every task is completed, the service returns to the work state</li>
						<li>Test that if a goToWork dispatch arrives, the service returns to the work state</li>
						<li>Test if the service correctly sends moveToPark/moveToOut messages to the trolley (via its CoAP-observable state)</li>
						<li>Test if the service doesn't instruct the trolley to moveToOut if the inserted token is invalid (e.g. that a exit(0) reply is sent)
					</ul>
				<h4>ManagerService</h4>
					Test code can be found at <a target="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/ManagerServiceUnitTest.kt">ManagerServiceUnitTest.kt</a>
					<ul>
						<li>Test if the service, basing on the trolley state, emits the right events after a toggle dispatch arrives (both from the CoAP-observable state and the Kwnoledge base)</li>
					</ul>
			<h3>Integration tests / Functional tests</h3>
				<h4>Test Plan 1</h4>
					This test plan will work as an integration test for the ParkServiceStatusGUI, ManagerService and Trolley components; it will also work as a functional test for the Parking Manager use cases (POR <em>manage</em>). <br>
					Test code can be found at <a target="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/TestPlan1.kt">TestPlan1.kt</a>
				<h4>Test Plan 2</h4>
					This test plan will work as an integration test for the IndoorParkingServiceGUI, ClientService and Trolley components; it will also work as a functional test for client "Parking Phase" use case (PORs <em>acceptIN</em>, <em>informIN</em>, <em>moveToIn</em>, <em>moveToSlotIn and <em>receipt</em></em>). <br>
					Test code can be found at <a target="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/TestPlan2.kt">TestPlan2.kt</a>
				<h4>Test Plan 3</h4>
					This test plan will work as an integration test for the OutdoorParkingServiceGUI, ClientService and Trolley components; it will also work as a functional test for client "Car Pickup" use case (PORs <em>acceptOUT</em> and <em>moveToSlotOut</em>). <br>
					Test code can be found at <a target="code" href="../test/it.sembrava_qualcuno.unibo.tf21Start/TestPlan3.kt">TestPlan3.kt</a><br>
		</div>
		<h2>Summary of the Analysis phase</h2>
			<table class="sprint">
						<thead>
							<tr>
								<th>Logic Architecture</th>
								<th>First Executable Model</th>
								<th>First Test Plans</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<center><a href="./img/ModelloEseguibile.png">ModelloEseguibile.png</center>
								</td>
								<td>
									<center><a target="code" href="../src/parkingArea.qak">parkingArea.qak</a></center>
								</td>
								<td>
								<center>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/TrolleyUnitTest.kt">TrolleyUnitTest.kt</a><br>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/ClientServiceUnitTest.kt">ClientServiceUnitTest.kt</a><br>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/ManagerServiceUnitTest.kt">ManagerServiceUnitTest.kt</a><br>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/TestPlan1.kt">TestPlan1.kt</a><br>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/TestPlan2.kt">TestPlan2.kt</a><br>
									<a target="code" href="../test/it.sembrava_qualcuno.tf21Start/TestPlan3.kt">TestPlan3.kt</a>
								</center>
								</td>
							</tr>
						</tbody>
					</table>
		<div class="footer">
			<center>			
				<table style="background-color:rgba(30, 22, 255, 0.9); width:60%;text-align:center;color:white">	
					<tr>
						<td colspan="2">By</td>
					</tr>
					<tr>
						<td style="width:50%">
							<img src="./img/bongiovanni_luca.jpg" style="width:50%"> <br/>
							Luca Bongiovanni <br/>
							email: luca.bongiovanni@studio.unibo.it
						</td>
						<td style="width:50%">
							<img src="./img/fototessera gmdc.jpg"  style="width:50%"><br/>
							Gian Marco De Cola <br/>		 
							email: gianmarco.decola@studio.unibo.it			 
						</td>
					</tr>
					<tr>
						<td colspan="2">
							<b>PROJECT REPO</b>: <a style="color: white;" href="https://github.com/sembrava-qualcuno/issLab21/tree/master/it.sembrava_qualcuno.unibo.tf21Start">
							https://github.com/sembrava-qualcuno/issLab21/tree/master/it.sembrava_qualcuno.unibo.tf21Start</a>
						</td>
					</tr>
				</table>
			</center>
		</div>
	</body>
</html>
