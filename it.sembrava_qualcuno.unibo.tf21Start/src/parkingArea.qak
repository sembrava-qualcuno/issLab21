/*
 * parkingArea.qak
 * ------------------------------------------------------------------
 * 
 * ASSUMPTIONS:
 *	- INDOOR  : cell (6,0)
 *  - OUTDOOR : cell (6,4)
 *  - One free parking slot : cell(3,2)	SLOTNUM=5
 *  - One client at a time
 *  - No sensors and fan
 *  - Temperature over TMAX (the trolley can be stopped)
 *	- The token corresponds to the parking slot number
 *  - The client who picks up a car waits until the trolley transports his/her car to the OUTDOOR
 *  - The parking manager is already logged in
 */

System carparking

//INDOOR CLIENT
//acceptIN
Request reqenter : reqenter(X)
Reply   enter    : enter(SLOTNUM)

//informIN
Request carenter : carenter(SLOTNUM)
Reply   receipt  : receipt(TOKENID)

Dispatch goToWork : goToWork(X)

Dispatch moveToPark : moveToPark(SLOTNUM)

//OUTDOOR CLIENT
//acceptOUT
Request reqexit : reqexit(TOKENID)
Reply 	exit 	: exit(X)

Dispatch moveToOut : moveToOut(SLOTNUM)

//PARK MANAGER
Dispatch toggleState : toggleState(X)

//PARK MANAGER SERVICE
Event stop	 : stop(X)
Event resume : resume(X)

//TROLLEY
Dispatch goToIdle : goToIdle(X)

Context ctxcarparking ip[host="localhost" port=8002]

QActor indoorparkingservicegui context ctxcarparking {
	[# var SLOTNUM = 0 #]
	
	State s0 initial {
		println("indoorparkingservicegui STARTS")
		updateResource [# "indoorparkingservicegui STARTS" #]
	}
	Goto requestToenter
	
	State requestToenter {
		println("indoorparkingservicegui requestToenter")
		updateResource [# indoorparkingservicegui requestToenter #]
		
		request parkclientservice -m reqenter : reqenter(bob)
	}
	Transition t0
		whenTime 1000 -> retrylater		//The client does not wait forever...
	    whenReply enter -> enterthecar
	
	State enterthecar {
 		onMsg(enter : enter(SLOTNUM)){
			[# SLOTNUM = payloadArg(0).toInt() #]
			
			println("indoorparkingservicegui receives SLOTNUM = $SLOTNUM")
			updateResource [# "indoorparkingservicegui receives SLOTNUM = $SLOTNUM" #]
		}		
	}
	Goto retrylater if [# SLOTNUM == 0 #] else movethecartoindoor
	
	State movethecartoindoor {
		println("indoorparkingservicegui moving the car in the INDOOR and press CARENTER")
		updateResource [# "indoorparkingservicegui oving the car in the INDOOR and press CARENTER" #]
		
		request parkclientservice -m carenter : carenter($SLOTNUM)		
	}
	Transition t0 
		whenReply receipt -> afterreceipt
	
	//The client leaves
	State afterreceipt {
		println("indoorparkingservicegui leaves")
		updateResource [# "indoorparkingservicegui leaves" #]
	}
	
	//The client leaves, notify it to the parkclientservice
	State retrylater {
		println("indoorparkingservicegui will retry later")
		updateResource [# "indoorparkingservicegui will retry later" #]
		
		forward parkclientservice -m goToWork : goToWork(bob)
	}
}

QActor outdoorparkingservicegui context ctxcarparking {
	State s0 initial {
		println("outdoorparkingservicegui STARTS")
		updateResource [# "outdoorparkingservicegui STARTS" #]
	}
	Goto requestToExit
	
	State requestToExit {
		println("outdoorparkingservicegui requestToExit")
		updateResource [# "outdoorparkingservicegui requestToExit" #]
		
		request parkclientservice -m reqexit : reqexit(TOKENID)
	}
	Transition t0
	    whenReply exit -> afterreceipt
	
	//The client leaves
	State afterreceipt {
		println("outdoorparkingservicegui leaves")
		updateResource [# "outdoorparkingservicegui leaves" #]
	}
}
 
QActor parkclientservice context ctxcarparking {
	State s0 initial {
		println("parkclientservice STARTS")
		updateResource [# "parkclientservice STARTS" #]
	}
	Goto work
	
	State work {
		println("parkclientservice waiting ...")
		updateResource [# "parkclientservice waiting ..." #]
	}
	Transition t0 
		whenRequest reqenter -> handleEnterRequest
		whenRequest reqexit -> handleOutRequest
	
	State handleEnterRequest{
		println("parkclientservice reply to reqenter")
		updateResource [# "parkclientservice reply to reqenter" #]
		printCurrentMessage
		
		//acceptIN
		//The trolley state can also be retrieved through the COAP protocol using it.unibo.tf21Analisi/resources/utils/CoapObserver.kt
		if [# utils.ParkingAreaKb2.indoorfree && !utils.ParkingAreaKb2.trolleyStopped #] {
			//Get first free parking spot, or 0
			[# 
				var SLOTNUM = 0
				var i
				for(i = 0; i <= 5 && SLOTNUM == 0; i++) {
					if(utils.ParkingAreaKb2.slotStateFree[i] == true) {
						SLOTNUM = i + 1
						utils.ParkingAreaKb2.slotStateFree[i] == false
					}
				}
			#]
			
			//informIN
			println("parkclientservice reply enter($SLOTNUM)")
			updateResource [# "parkclientservice reply enter($SLOTNUM)" #]
			
			replyTo reqenter with enter : enter($SLOTNUM)
			
			if [# SLOTNUM == 0 #] {
				forward parkclientservice -m goToWork : goToWork(enter(0))
				//backToHome requirement has been incorporated in trolley's idle state
			}
		}
		else {
			//Reply with slotnum=0 to indicates both indoor area and trolley are occupied
			println("parkclientservice reply enter($SLOTNUM)")
			updateResource [# "parkclientservice reply enter($SLOTNUM)" #]
			
			replyTo reqenter with enter : enter(0)
			forward parkclientservice -m goToWork : goToWork(enter(0))
		}
	}
	Transition t0
		whenMsg goToWork -> work
		whenRequest carenter -> enterthecar
	
	State enterthecar{
		printCurrentMessage		
		println("parkingmanagerservice reply to enterthecar")
 		onMsg(carenter : carenter(SLOT)){
			[# var SLOTNUM = payloadArg(0).toInt() #]
			
			//moveToPark
			forward trolley -m moveToPark : moveToPark($SLOTNUM)
			
			//Reply with the TOKENID
			replyTo carenter with receipt : receipt($SLOTNUM)
			println("parkingmanagerservice moves the car to SLOTNUM = $SLOTNUM ")
		}		
	}
	Goto work
	
	State handleOutRequest {
		println("parkingmanagerservice reply to reqexit")
		
		onMsg(reqexit : reqexit(TOKENID)) {
			//findSlot
			[# var CARSLOTNUM = payloadArg(0).toInt() #]
			
			//Check if the tokenid is valid
			if [# TOKENID >= 1 && TOKENID <= 6 && !utils.ParkingAreaKb2.slotStateFree[TOKENID - 1] #] {
				//moveToOut
				forward trolley -m moveToOut : moveToOut($CARSLOTNUM)
			}
			else {
				//Error
				[# CARSLOTNUM = 0 #]
			}
			
			replyTo reqexit with exit : exit($CARSLOTNUM)
		}
	}
	Goto work
}

QActor parkservicestatusgui context ctxcarparking {
	State s0 initial {
		println("parkservicestatusgui STARTS")
		updateResource [# "parkservicestatusgui STARTS" #]
	}
	Goto toggleState
	
	State toggleState {
		println("parkservicestatusgui toggle state")
		updateResource [# "parkservicestatusgui toggle state" #]
		forward parkmanagerservice -m toggleState : toggleState(X)
		delay 1000
		println("parkservicestatusgui toggle state")
		updateResource [# "parkservicestatusgui toggle state" #]
		forward parkmanagerservice -m toggleState : toggleState(X)
	}
}

QActor parkmanagerservice context ctxcarparking {
	State s0 initial {
		println("parkmanagerservice STARTS")
		updateResource [# "parkmanagerservice STARTS" #]
	}
	
	State work {
		println("parkmanagerservice waiting ...")
		updateResource [# "parkmanagerservice waiting ..." #]
	}
	Transition t0
		whenMsg toggleState -> toggleTrolleyState
	
	State toggleTrolleyState {
		if [# utils.ParkingAreaKb2.trolleyStopped #] {
			[# utils.ParkingAreaKb2.trolleyStopped = false #]
			
			println("parkmanagerservice emit resume")
			updateResource [# "parkmanagerservice emit resume" #]
			emit resume : resume(X)
		}
		else {
			[# utils.ParkingAreaKb2.trolleyStopped = true #]
			
			println("parkmanagerservice emit stop")
			updateResource [# "parkmanagerservice emit stop" #]
			emit stop : stop(X)
		}
	}
	Goto work
}

QActor trolley context  ctxcarparking{
	State s0 initial {
		println("trolley STARTS")
		updateResource [# "trolley STARTS" #]
	}
	
	State idle {
		println("trolley IDLE")
		updateResource [# "trolley IDLE" #]
		
		//Moves the trolley to the home position if not there already
	}
	Transition t0
		whenEvent stop -> stopped
		whenMsg moveToPark -> working
		whenMsg moveToOut -> working
	
	State working {
		printCurrentMessage
		
		onMsg(moveToPark : moveToPark(SLOTNUM)) {
			println("trolley moveToPark")
			updateResource [# "trolley moveToPark" #]
			
			//Move the trolley to the INDOOR area
			
			//Move the trolley to the specific parking slot	
		}
		
		onMsg(moveToOut : moveToOut(SLOTNUM)) {
			println("trolley moveToOut")
			updateResource [# "trolley moveToOut" #]
						
			//Move the trolley to the specific parking slot
			
			//Move the trolley to the OUTDOOR area
		}
		
		forward trolley -m goToIdle : goToIdle(X)
	}
	Transition t0
		whenEvent stop -> stopped
		whenMsg goToIdle -> idle
	
	State stopped {
		println("trolley STOPPED")
		updateResource [# "trolley STOPPED" #]
	}
	Transition t0
		whenEvent resume -> working
}
 